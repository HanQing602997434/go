
// 抽象
/*
	如何理解抽象
		我们在前面去定义一个结构体时候，实际上就是把一类十五的共有属性(字段)
		和行为(方法)提取出来，形成一个物理模型(模板)。这种研究问题的方法称为
		抽象。
		
	封装
		封装就是把抽象出的字段和对字段的操作封装在一起，数据被保护在内部，程序
		的其他包只能通过被授权的操作(方法)，才能对字段进行操作

		封装的理解和好处
			1）隐藏实现细节
			2）可以对数据进行验证，保证安全合理

		如何体现封装
			1）对结构体中的属性进行封装
			2）通过方法、包实现封装

		封装的实现步骤
			1）将结构体、字段(属性)的首字母小写(不能导出了，其他包不能使用，类似private)
			2）给结构体所在包提供一个工厂模式的函数，首字母大写。类似一个构造函数
			3）提供一个首字母大写的Set方法(类似其它语言的public)，用于对属性判断并赋值
				func (var 结构体类型名)SetXxx(参数列表) (返回值列表) {
					// 假如数据验证的业务逻辑
					var.字段 = 参数
				}
			4）提供一个首字母大写的Get方法(类似其它语言的public)，用于获取属性的值
				func (var 结构体类型名)
			特别说明：在Go开发中并没有特别强调封装

	继承
		继承基本介绍和示意图
			继承可以解决代码复用，让我们的编程更加靠近人类思维

			当多个结构体存在相同的属性(字段)和方法时，可以从这些结构体中抽象出结构体(比如刚才的
			Student)在该结构体中定义这些相同的属性和方法。

			其它的结构体不需要重新定义这些属性和方法，只需要嵌套一个Student匿名结构体即可。

			也就是说：在Golang中，如果一个struct嵌套了另一个匿名结构体，那么这个结构体可以直接访
			问匿名结构体的字段和方法，从而实现了继承特性。

		嵌套匿名结构体的基本语法
			type Goods struct {
				Name string
				Price int
			}

			type Book struct {
				Goos // 这里就是嵌套匿名结构体Goods
				Writer string 
			}

	继承的细节
		1）结构体可以使用嵌套匿名结构体所有的字段和方法，即：首字母大写或者小写的字段、方法，都可以
		使用。
		2）当我们直接通过b访问字段或方法时，其执行流程如下比如 b.Name，编译器会先看b对应的类型有没有
		name，如果有，则直接调用B类型的Name字段，如果没有就去查看B中嵌入的匿名结构体A有没有声明Name
		字段，如果有就调用，如果没有继续查找，如果都找不到就报错。
		3）当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如希望访问匿名结构体
		的字段和方法，可以通过匿名结构体名来区分
		4）结构体嵌入两个（或多个）匿名结构体，如两个匿名结构体有相同的字段和方法（同时结构体本身没有同
		名的字段和方法），在访问时，就必须明确指定匿名结构体名字，否则编译报错。
		5）如果一个struct嵌套了一个有名结构体，这种模式就是组合，如果是组合关系，那么在访问组合的结构体
		的字段或方法时，必须带上结构体的名字。
		6）嵌套匿名结构体后，也可以在创建结构体变量时，直接指定各个匿名结构体字段的值。
		tv := TV{ 
			Goods{
				Name : "电视机001",
				Price : 5000.99,
			},
			Brand{
				Name : "海尔",
				Address : "山东",
			},
		}
*/	